#!/usr/bin/python3
# -*- coding: utf-8 -*-
# kate: space-indent on; indent-width 4; mixedindent off; indent-mode python;

import sys
import os
import argparse
import string
from textwrap import TextWrapper
import subprocess
import re
import shutil
import glob
#from arsoft.utils import runcmdAndGetData

from config import *
from changelog import package_changelog
from packagegroups import all_package_groups

source_pkg = "\
Source: " + source_package_name + "\n\
Section: misc\n\
Priority: optional\n\
Maintainer: " + package_maintainer + "\n\
Homepage: " + package_homepage + "\n\
Build-Depends: debhelper (>= " + str(package_debhelper) + ")\n\
Standards-Version: " + str(package_standardsversions) + "\n\
"

rules_file_header = "\
#!/usr/bin/make -f\n\
# debian/rules for " + source_package_name + ". GNU copyright 2010-2014 by " + package_maintainer + ".\n\
\n\
#export DH_VERBOSE=1\n\
\n\
build:\n\
\n\
clean:\n\
\tdh_testdir\n\
\tdh_testroot\n\
\tdh_clean\n\
\n\
install: build\n\
\tdh_testdir\n\
\tdh_testroot\n\
\tdh_prep\n\
"
rules_file_footer = "\
\n\
binary-indep: install\n\
\tdh_testdir\n\
\tdh_testroot\n\
\tdh_install\n\
\tdh_installdocs\n\
\tdh_installchangelogs\n\
\tdh_compress\n\
\tdh_fixperms\n\
\tdh_installdeb\n\
\tdh_gencontrol\n\
\tdh_md5sums\n\
\tdh_builddeb\n\
\n\
binary-arch: install\n\
\n\
binary: binary-indep binary-arch\n\
.PHONY: build clean binary-indep binary-arch binary install\n\
"

readme_debian_file = "\
README for Debian\n\
"

copyright_file = "\
Copyright 2010-2014 by " + package_maintainer + "\n\
\n\
The files in this package are free software; you can redistribute them\n\
and/or modify them under the terms of the GNU General Public License\n\
as published by the Free Software Foundation; either version 2, or (at\n\
your option) any later version.\n\
\n\
The files in this package are distributed in the hope that they will\n\
be useful, but WITHOUT ANY WARRANTY; without even the implied warranty\n\
of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n\
General Public License for more details.\n\
\n\
You should have received a copy of the GNU General Public License\n\
with your Debian GNU/Linux system, in /usr/share/common-licenses/GPL,\n\
or with the Debian GNU/Linux bash source package as the file COPYING.\n\
If not, write to the Free Software Foundation, Inc., 51 Franklin St,\n\
Fifth Floor, Boston, MA 02110-1301, USA.\n\
"

def runcmdAndGetData(args=[], script=None, verbose=False, outputStdErr=False, outputStdOut=False,
                     executable=None, shell='/bin/sh',
                     stdin=None, stdout=None, stderr=None, stderr_to_stdout=False, input=None, cwd=None, env=None,
                     runAsUser=None, su='/bin/su'):

    script_tmpfile = None
    if script is None:
        if args:
            if runAsUser is None:
                all_args = args
            else:
                all_args = [su, '-s', shell, '-', str(runAsUser), '-c', ' '.join(args)]
        else:
            raise ValueError('neither commandline nor script specified.')
    else:
        try:
            script_tmpfile = tempfile.NamedTemporaryFile()
            script_tmpfile.write(script.encode())
        except IOError:
            script_tmpfile = None

        all_args = [str(shell)]
        all_args.append(script_tmpfile.name)

    if input is not None:
        stdin_param = subprocess.PIPE
    else:
        stdin_param = stdin if stdin is not None else subprocess.PIPE
    if stdout is not None and hasattr(stdout, '__call__'):
        stdout_param = subprocess.PIPE
    else:
        stdout_param = stdout if stdout is not None else subprocess.PIPE
    if stderr_to_stdout:
        stderr_param = subprocess.STDOUT
    else:
        if stdout is not None and hasattr(stdout, '__call__'):
            stderr_param = subprocess.PIPE
        else:
            stderr_param = stdout if stdout is not None else subprocess.PIPE
    if verbose:
        print("runcmd " + ' '.join(all_args) +
                ' 0<%s 1>%s 2>%s' % (stdin_param, stdout_param, stderr_param)
                    )

    p = subprocess.Popen(all_args, executable=executable, stdout=stdout_param, stderr=stderr_param, stdin=stdin_param, shell=False, cwd=cwd, env=env)
    if p:
        if stdout is not None and hasattr(stdout, '__call__'):
            encoding = 'CP1252' if platform.system() == 'Windows' else 'utf-8'
            while True:
                line = ""
                try:
                    line = p.stdout.readline()
                except Exception:
                    pass
                try:
                    line = line.decode(encoding)
                except:
                    continue
                if not line:
                    break
                line = line.rstrip('\n\r')
                stdout(line)
            sts = p.wait()
            stdoutdata = None
            stderrdata = None
        else:
            if input:
                (stdoutdata, stderrdata) = p.communicate(input.encode())
            else:
                (stdoutdata, stderrdata) = p.communicate()
            if stdoutdata is not None and outputStdOut:
                if int(python_major) < 3: # check for version < 3
                    sys.stdout.write(stdoutdata)
                    sys.stdout.flush()
                else:
                    sys.stdout.buffer.write(stdoutdata)
                    sys.stdout.buffer.flush()
            if stderrdata is not None and outputStdErr:
                if int(python_major) < 3: # check for version < 3
                    sys.stderr.write(stderrdata)
                    sys.stderr.flush()
                else:
                    sys.stderr.buffer.write(stderrdata)
                    sys.stderr.buffer.flush()
            sts = p.returncode
    else:
        sts = -1
        stdoutdata = None
        stderrdata = None
    return (sts, stdoutdata, stderrdata)

class application(object):
        
    def control_line(self, name, value):
        ret = name + ": "
        wrapper = TextWrapper()
        wrapper.initial_indent = ''
        wrapper.subsequent_indent = ' '
        wrapper.break_on_hyphens = False
        wrapper.break_long_words = False
        
        lines = wrapper.wrap(value)
        first = True
        for line in lines:
            ret = ret + line + '\n'
        return ret
        
    def control_description(self, desc):
        ret = ''
        wrapper = TextWrapper()
        wrapper.initial_indent = ' '
        wrapper.subsequent_indent = ' '
        wrapper.break_on_hyphens = False
        wrapper.break_long_words = False
        lines = wrapper.wrap(desc)
        for line in lines:
            ret = ret + line + '\n'
        return ret
    
    def _calc_full_depends(self, name, prefix, choices, distribution):
        ret_depends = set()
        ret_packages = set()
        mydepends = set()
        for element in choices:
            if element['name'] == name:
                if 'depends' in element:
                    mydepends |= set(element['depends'])
                if 'packages' in element:
                    ret_packages |= set(element['packages'])
                if 'packages-' + distribution in element:
                    ret_packages |= set(element['packages-' + distribution])
                break;
        self.debug('_calc_full_depends: ' + name + ' mydepends=' + str(mydepends))
        for mydep in mydepends:
            if isinstance(mydep, tuple):
                mydep_all_depends = list()
                for mydep_item in mydep:
                    mydep_item_real = mydep_item
                    for element in choices:
                        if mydep_item == element['name']:
                            if 'mainpackage' in element:
                                mainpackage = bool(element['mainpackage'])
                            else:
                                mainpackage = False
                            if mainpackage:
                                dep_package_name = prefix
                            else:
                                dep_package_name = prefix + '-' + element['name']

                            (element_depends, element_packages) = self._calc_full_depends(element['name'], prefix, choices, distribution)

                            mydep_item_real = dep_package_name
                            ret_depends |= set(element_depends)
                            ret_packages |= element_packages
                            break
                    mydep_all_depends.append(mydep_item_real)
                #print(tuple(mydep_all_depends))
                ret_depends.add(tuple(mydep_all_depends))
            else:
                for element in choices:
                    if mydep == element['name']:
                        if 'mainpackage' in element:
                            mainpackage = bool(element['mainpackage'])
                        else:
                            mainpackage = False
                        if mainpackage:
                            dep_package_name = prefix
                        else:
                            dep_package_name = prefix + '-' + element['name']

                        (element_depends, element_packages) = self._calc_full_depends(element['name'], prefix, choices, distribution)

                        ret_depends.add(dep_package_name)
                        ret_depends |= set(element_depends)
                        ret_packages |= element_packages
                        break
        self.debug('_calc_full_depends: ' + name + ' return ret_depends=' + str(ret_depends) + ', ret_packages=' + str(ret_packages))
        return (ret_depends, ret_packages)

    def _calc_descendants(self, name, prefix, choices, distribution):
        ret_depends = set()
        ret_packages = set()
        myrealname = name
        for element in choices:
            if element['name'] == name:
                if 'mainpackage' in element:
                    mainpackage = bool(element['mainpackage'])
                else:
                    mainpackage = False
                if mainpackage:
                    myrealname = prefix
                else:
                    myrealname = prefix + '-' + element['name']
                break
        for element in choices:
            if name != element['name']:
                (element_depends, element_packages) = self._calc_full_depends(element['name'], prefix, choices, distribution)
                if myrealname in element_depends:
                    if 'mainpackage' in element:
                        mainpackage = bool(element['mainpackage'])
                    else:
                        mainpackage = False
                    if mainpackage:
                        dep_package_name = prefix
                    else:
                        dep_package_name = prefix + '-' + element['name']
                    
                    ret_depends.add(dep_package_name)
                    ret_depends |= set(element_depends)
                    ret_packages |= element_packages
        return (ret_depends, ret_packages)
    
    def package_group(self, distribution, prefix, choices, package_version):
        all_packages = set()
        all_package_names = set()
        package_depends = {}
        for element in choices:
            if 'mainpackage' in element:
                mainpackage = bool(element['mainpackage'])
            else:
                mainpackage = False
            if mainpackage:
                package_name = prefix
            else:
                package_name = prefix + '-' + element['name']

            if 'packages' in element:
                for pkg in element['packages']:
                    if isinstance(pkg, tuple):
                        for tup_elem in pkg:
                            all_packages.add(tup_elem)
                    else:
                        all_packages.add(pkg)
            if 'packages-' + distribution in element:
                for pkg in element['packages-' + distribution]:
                    if isinstance(pkg, tuple):
                        for tup_elem in pkg:
                            all_packages.add(tup_elem)
                    else:
                        all_packages.add(pkg)
            all_package_names.add(package_name)
            
        #print '1st all ' + str(all_packages)
        #print '1st all names ' + str(all_package_names)
        ret = ''
        for element in choices:
            internal_name = prefix + '-' + element['name']
            if 'mainpackage' in element:
                mainpackage = bool(element['mainpackage'])
            else:
                mainpackage = False
            if mainpackage:
                name = prefix
            else:
                name = prefix + '-' + element['name']

            if 'packages' in element:
                depend_packages = set(element['packages'])
            else:
                depend_packages = set()
            if 'packages-' + distribution in element:
                depend_packages = depend_packages | set(element['packages-' + distribution])

            if 'depends' in element:
                depend_groups = set(element['depends'])
            else:
                depend_groups = set()
            if 'side-by-side' in element:
                sidebyside_packages = set(element['side-by-side'])
            else:
                sidebyside_packages = set()
            if 'conflicts' in element:
                element_conflicts = set(element['conflicts'])
            else:
                element_conflicts = set()
            if 'conflicts-' + distribution in element:
                element_conflicts = element_conflicts | set(element['conflicts-' + distribution])
            if 'replaces' in element:
                element_replaces = set(element['replaces'])
            else:
                element_replaces = set()
            if 'noconflicts' in element:
                element_noconflicts = set(element['noconflicts'])
            else:
                element_noconflicts = set()
            if 'noconflicts-' + distribution in element:
                element_noconflicts = element_noconflicts | set(element['noconflicts-' + distribution])

            (element_depends, element_packages) = self._calc_full_depends(element['name'], prefix, choices, distribution)
            (element_descendants_depends, element_descendants_packages) = self._calc_descendants(element['name'], prefix, choices, distribution)

            # compute the conflicting packages
            conflict_packages = all_packages.copy()
            conflict_packages.update(element_conflicts)
            conflict_packages -= element_noconflicts
            for pkg in element_packages:
                if isinstance(pkg, tuple):
                    for tup_elem in pkg:
                        conflict_packages.remove(tup_elem)
                else:
                    if pkg in conflict_packages:
                        conflict_packages.remove(pkg)
            
            conflict_packages -= element_descendants_packages
            conflict_other_packages = all_package_names.copy()
            conflict_other_packages.remove(name)
            for pkg in element_depends:
                if isinstance(pkg, tuple):
                    for tup_elem in pkg:
                        conflict_other_packages.remove(tup_elem)
                else:
                    if pkg in conflict_other_packages:
                        conflict_other_packages.remove(pkg)
            conflict_other_packages -= element_descendants_depends
            
            for dep_element in choices:
                if 'mainpackage' in dep_element:
                    mainpackage = bool(dep_element['mainpackage'])
                else:
                    mainpackage = False
                if mainpackage:
                    dep_package_name = prefix
                else:
                    dep_package_name = prefix + '-' + dep_element['name']
                if 'depends' in dep_element:
                    dep_depends = set(dep_element['depends'])
                else:
                    dep_depends = set()
                if 'packages' in dep_element:
                    dep_element_packages = set(dep_element['packages'])
                else:
                    dep_element_packages = set()
                if 'packages-' + distribution in dep_element:
                    dep_element_packages = dep_element_packages | set(dep_element['packages-' + distribution])

                if element['name'] in dep_depends:
                    self.debug('pkg: ' + dep_package_name + ' depends on current package ' + element['name'] + ' remove from ' + str(conflict_other_packages))
                    if dep_package_name in conflict_other_packages:
                        conflict_other_packages.remove(dep_package_name)
                    conflict_packages -= dep_element_packages
                self.debug('pkg: ' + dep_package_name + ' depend_groups=' + str(depend_groups))
                current_depend_groups = list()
                for dep_grp in depend_groups:
                    if isinstance(dep_grp, tuple):
                        if dep_element['name'] in dep_grp:
                            current_depend_groups.append(dep_grp)
                    else:
                        if dep_grp == dep_element['name']:
                            current_depend_groups.append(dep_element['name'])
                            break

                if current_depend_groups:
                    self.debug('pkg: ' + name + ' remove ' + dep_package_name + '/' + dep_element['name'] + ' from ' + str(conflict_packages))
                    if dep_package_name in conflict_other_packages:
                        conflict_other_packages.remove(dep_package_name)
                    conflict_packages -= dep_element_packages

                    for dep_grp in current_depend_groups:
                        if isinstance(dep_grp, tuple):
                            all_dep = list()
                            for dep_grp_elem in dep_grp:
                                dep_grp_elem_package_name = dep_grp_elem
                                for dep_element in choices:
                                    if dep_element['name'] != dep_grp_elem:
                                        continue
                                    if 'mainpackage' in dep_element:
                                        mainpackage = bool(dep_element['mainpackage'])
                                    else:
                                        mainpackage = False
                                    if mainpackage:
                                        dep_grp_elem_package_name = prefix
                                    else:
                                        dep_grp_elem_package_name = prefix + '-' + dep_element['name']

                                all_dep.append(dep_grp_elem_package_name + '(=' + package_version + ')')
                            depend_packages.add(tuple(all_dep))
                        else:
                            depend_packages.add(dep_package_name + '(=' + package_version + ')')
                elif dep_element['name'] in sidebyside_packages:
                    #print 'side by side ' + dep_package_name
                    if dep_package_name in conflict_other_packages:
                        conflict_other_packages.remove(dep_package_name)
                    conflict_packages -= dep_element_packages
                
            conflict_packages.update(conflict_other_packages)
            
            # compute the replaces packages
            replace_packages = set()
            replace_packages.update(element_replaces)
            
            #print 'deps ' + str(depend_packages)
            #print 'all ' + str(all_packages)
            #print 'cf ' + str(conflict_packages)
            if depend_packages is not None:
                full_depend_packages = set()
                for pkg in depend_packages:
                    if isinstance(pkg, tuple):
                        entry = ' | '.join(pkg)
                    else:
                        entry = pkg
                    full_depend_packages.add(entry)
                depends = ', '.join(full_depend_packages)
            else:
                depends = None
            if conflict_packages is not None:
                conflicts = ', '.join(conflict_packages)
            else:
                conflicts = None
            if replace_packages is not None:
                replaces = ', '.join(replace_packages)
            else:
                replaces = None
            
            pkg_install = ''
            pkg_install = pkg_install + "\n"
            pkg_install = pkg_install + self.control_line("Package", name)
            pkg_install = pkg_install + self.control_line("Architecture", 'all')
            if depends is not None and len(depends) != 0:
                pkg_install = pkg_install + self.control_line("Depends", "${misc:Depends}, " + depends)
            else:
                pkg_install = pkg_install + self.control_line("Depends", "${misc:Depends}")
            if conflicts is not None and len(conflicts) != 0:
                pkg_install = pkg_install + self.control_line("Conflicts", conflicts)
            if replaces is not None and len(replaces) != 0:
                pkg_install = pkg_install + self.control_line("Replaces", replaces)
            if 'shortdesc' in element and element['shortdesc']:
                pkg_install = pkg_install + self.control_line("Description", element['shortdesc'])
                if 'description' in element and element['description']:
                    pkg_install = pkg_install + self.control_description(element['description'])
                else:
                    pkg_install = pkg_install + self.control_description(element['shortdesc'] + '.')
            self.debug("Package: " + name + 
                        "\n  Depends:" + str(depends) +
                        "\n  Conflicts:" + str(conflicts))
            ret += pkg_install
        return ret

    def package_group_postinst(self, package_debian_dir, distribution, prefix, choices):
        for element in choices:
            if 'mainpackage' in element:
                mainpackage = bool(element['mainpackage'])
            else:
                mainpackage = False
            if mainpackage:
                package_name = prefix
            else:
                package_name = prefix + '-' + element['name']

            diverts = element['divert'] if 'divert' in element else []
            if diverts:
                postinst_content = "#!/bin/sh -e\nPKG=%s\nif [ \"$1\" = configure ] ; then\n" % (package_name)
                for (div_target, div_file) in diverts:
                    div_dict = { 'div_target':div_target, 'div_file': div_file, 'package_name':package_name }
                    postinst_content = postinst_content + "    dpkg-divert --add --package %(package_name)s --rename --divert %(div_target)s.distrib %(div_target)s\n" % div_dict
                    postinst_content = postinst_content + "    [ ! -e %(div_target)s ] && cp -p /usr/share/%(package_name)s/%(div_file)s %(div_target)s\n" % div_dict

                postinst_content = postinst_content + "fi\n#DEBHELPER#\nexit 0\n"

                package_postinst_file = os.path.join(package_debian_dir, package_name + '.postinst')

                f = open(package_postinst_file, 'w')
                f.write(postinst_content)
                f.close()
                os.chmod(package_postinst_file, 0o755)

                prerm_content = "#!/bin/sh -e\nPKG=%s\nif [ \"$1\" = remove ] ; then\n" % (package_name)
                for (div_target, div_file) in diverts:
                    div_dict = { 'div_target':div_target, 'div_file': div_file, 'package_name':package_name }
                    prerm_content = prerm_content + "    dpkg-divert --remove --package %(package_name)s --rename --divert %(div_target)s.distrib %(div_target)s\n" % div_dict

                prerm_content = prerm_content + "fi\n#DEBHELPER#\nexit 0\n"

                package_prerm_file = os.path.join(package_debian_dir, package_name + '.prerm')

                f = open(package_prerm_file, 'w')
                f.write(prerm_content)
                f.close()
                os.chmod(package_prerm_file, 0o755)

    def package_group_install_files(self, package_dir, package_debian_dir, distribution, prefix, choices):
        ret = ''
        for element in choices:
            if 'mainpackage' in element:
                mainpackage = bool(element['mainpackage'])
            else:
                mainpackage = False
            if mainpackage:
                package_name = prefix
            else:
                package_name = prefix + '-' + element['name']

            files = element['files'] if 'files' in element else []
            if files:
                dest_dir = '/usr/share/' + package_name
                for (src, dest, mode) in files:

                    package_src = package_dir + '/' + src
                    package_src_dir = os.path.dirname(package_src)
                    if not os.path.isdir(package_src_dir):
                        os.makedirs(package_src_dir)
                    shutil.copy2( src, package_src)
                    dest_full = os.path.join(dest_dir, dest)
                    dest_full_dir = os.path.dirname(dest_full)
                    if dest_full_dir:
                        ret = ret + '\tinstall -d $(CURDIR)/debian/%(package_name)s%(dest)s\n' % \
                            { 'dest': dest_full_dir, 'package_name':package_name }
                    ret = ret + '\tinstall -m %(mode)o %(src)s $(CURDIR)/debian/%(package_name)s%(dest)s\n' % \
                        { 'src': src, 'dest': dest_full, 'mode': mode, 'package_name':package_name }
        return ret

    def make_package_dir(self, basedir, package_name, package_version, distribution, distribution_release=1):
        if basedir is None:
            basedir = os.getcwd()
        distribution_verno = all_distributions[distribution]
        package_dir = basedir + '/' + package_name + '-' + package_version + '~%s.%i' % (distribution_verno, distribution_release)
        package_debian_dir = package_dir + '/debian'
        package_debian_control = package_debian_dir + '/control'
        package_debian_changelog = package_debian_dir + '/changelog'
        package_debian_source_dir = package_debian_dir + '/source'
        if not os.path.exists(package_dir):
            os.mkdir(package_dir, 0o755)
        if not os.path.exists(package_debian_dir):
            os.mkdir(package_debian_dir, 0o755)
        if not os.path.exists(package_debian_source_dir):
            os.mkdir(package_debian_source_dir, 0o755)

        f = open(package_debian_source_dir + '/format', 'w')
        f.write('3.0 (native)') 
        f.close()
        
        f = open(package_debian_dir + '/compat', 'w')
        f.write(str(package_debhelper) + '\n') 
        f.close()
        
        rules_file = rules_file_header
        for (groupname, grouprules, groupopts) in all_package_groups:
            if 'distribution' in groupopts:
                groupdistribution = groupopts['distribution']
                build_group_for_distribution = True
                if distribution in groupdistribution:
                    build_group_for_distribution = True
                if ('!' + distribution) in groupdistribution:
                    build_group_for_distribution = False
            else:
                build_group_for_distribution = True

            #self.info('Build group ' + groupname + ' for distribution ' + distribution + ':' + str(build_group_for_distribution))

            if build_group_for_distribution:
                if self.selected_groups is not None:
                    if groupname in self.selected_groups:
                        include = True
                    else:
                        include = False
                else:
                    include = True
            else:
                include = False
            if include:
                ret = self.package_group_install_files(package_dir, package_debian_dir, distribution, groupname, grouprules)
                rules_file = rules_file + ret
            else:
                self.info('Skip group ' + groupname + ' for distribution ' + distribution)
        rules_file = rules_file + rules_file_footer

        f = open(package_debian_dir + '/rules', 'w')
        f.write(rules_file) 
        f.close()
        os.chmod(package_debian_dir + '/rules', 0o755)
        
        f = open(package_debian_dir + '/copyright', 'w')
        f.write(copyright_file) 
        f.close()
        
        f = open(package_debian_dir + '/README.Debian', 'w')
        f.write(readme_debian_file) 
        f.close()

        # copy this script file into the package dir
        this_script_dir = os.path.dirname(__file__)
        source_files = glob.glob(this_script_dir + '/*.py')
        source_files.extend( [__file__, 'LICENSE', 'Makefile', 'README.md'] )
        for f in source_files:
            shutil.copy2(os.path.abspath(f), package_dir)

        return (package_dir, package_debian_dir)

    def generate_debian_control(self, control_file, package_version, distribution, distribution_release=1):

        content = source_pkg
        distribution_verno = all_distributions[distribution]
        full_version = package_version + '~%s.%i' % (distribution_verno, distribution_release)
        for (groupname, grouprules, groupopts) in all_package_groups:
            if 'distribution' in groupopts:
                groupdistribution = groupopts['distribution']
                build_group_for_distribution = True
                if distribution in groupdistribution:
                    build_group_for_distribution = True
                if ('!' + distribution) in groupdistribution:
                    build_group_for_distribution = False
            else:
                build_group_for_distribution = True
                
            #self.info('Build group ' + groupname + ' for distribution ' + distribution + ':' + str(build_group_for_distribution))

            if build_group_for_distribution:
                if self.selected_groups is not None:
                    if groupname in self.selected_groups:
                        include = True
                    else:
                        include = False
                else:
                    include = True
            else:
                include = False
            if include:
                packages = self.package_group(distribution, groupname, grouprules, full_version)
                content = content + packages
            else:
                self.info('Skip group ' + groupname + ' for distribution ' + distribution)

        self.debug(content)

        f = open(control_file, 'w')
        f.write(content) 
        f.close()

    def generate_debian_postinst(self, package_debian_dir, distribution):

        for (groupname, grouprules, groupopts) in all_package_groups:
            if 'distribution' in groupopts:
                groupdistribution = groupopts['distribution']
                build_group_for_distribution = True
                if distribution in groupdistribution:
                    build_group_for_distribution = True
                if ('!' + distribution) in groupdistribution:
                    build_group_for_distribution = False
            else:
                build_group_for_distribution = True

            #self.info('Build group ' + groupname + ' for distribution ' + distribution + ':' + str(build_group_for_distribution))

            if build_group_for_distribution:
                if self.selected_groups is not None:
                    if groupname in self.selected_groups:
                        include = True
                    else:
                        include = False
                else:
                    include = True
            else:
                include = False
            if include:
                self.package_group_postinst(package_debian_dir, distribution, groupname, grouprules)
            else:
                self.info('Skip group ' + groupname + ' for distribution ' + distribution)

    def generate_debian_changelog(self, changelog_file, distribution, changelog, distribution_release=1):

        distribution_verno = all_distributions[distribution]
        content = ''
        for entry in changelog:

            full_version = entry['version'] + '~%s.%i' % (distribution_verno, distribution_release)
            e = source_package_name + ' (' + full_version + ') ' + distribution + '; urgency=' + entry['urgency'] + '\n'
            e = e + '\n'
            for i in entry['items']:
                e = e + '  * ' + i + '\n'
            e = e + '\n'
            e = e + ' -- ' + entry['author'] + '  ' + entry['date'] + '\n'
            e = e + '\n'
            content = content + e
            
        f = open(changelog_file, 'w')
        f.write(content)
        f.close()

    def get_latest_version_from_changelog(self, changelog, distribution):
        entry = changelog[0]
        full_version = entry['version']
        
        re_version_pattern = re.compile('^(?P<upstream_version>(\d+\.)?(\d+\.)?(\*|\d+))')
        result = re_version_pattern.match(full_version)
        if result is not None:
            short_version = result.group('upstream_version')
        else:
            short_version = ''
        return (source_package_name, full_version, short_version)

    def get_distribution_codename(self):
        (sts, stdout, stderr) = runcmdAndGetData(['/usr/bin/lsb_release', '-cs'])
        if sts != 0:
            self.error("Errors %i: %s" %(sts, stderr))
        else:
            ret = stdout.strip()
        return ret
        
    def do_build(self, package_dir, binary=False):
        args = ['debuild']
        if not binary:
            args.append('-S')
        (sts, stdout, stderr) = runcmdAndGetData(args, cwd=package_dir)
        if sts == 0:
            self.info("Build of " + package_dir + " successful.")
            ret = True
        else:
            self.error("Error %i: %s\n%s" %(sts, stdout, stderr))
            ret = False
        return ret

    def do_put(self, package_dir, version, distribution, distribution_release=1):
        distribution_verno = all_distributions[distribution]
        changesfile = package_dir + '/../' + source_package_name + '_' +  version + '~%s.%i_source.changes' % (distribution_verno, distribution_release)
        args = ['dput', changesfile]
        p = subprocess.Popen(args, cwd=package_dir, stdout=subprocess.PIPE, stderr=subprocess.PIPE) 
        if p is not None:
            err = p.wait()
            stdout_value, stderr_value = p.communicate()
            if err != 0:
                self.error("Errors " + str(err) + ": " + str(args) + "\n" + stdout_value + "\n" + stderr_value + "\n")
                ret = False
            else:
                self.info("Uploaded " + changesfile)
                ret = True
        else:
            self.error('Failed to create process: ', args)

    def do_clean(self, package_dir, version, distribution, distribution_release=1):
        filebasename = package_dir + '/../' + source_package_name + '_' +  version + '~' + distribution + str(distribution_release)
        changesfile = filebasename + '_source.changes'
        buildfile = filebasename + '_source.build'
        targzfile = filebasename + '.tar.gz'
        tarxzfile = filebasename + '.tar.xz'
        dscfile = filebasename + '.dsc'
        if os.path.exists(changesfile):
            os.remove(changesfile)
        if os.path.exists(buildfile):
            os.remove(buildfile)
        if os.path.exists(targzfile):
            os.remove(targzfile)
        print(tarxzfile)
        if os.path.exists(tarxzfile):
            os.remove(tarxzfile)
        if os.path.exists(dscfile):
            os.remove(dscfile)
        shutil.rmtree(package_dir)
        ret = True
        return ret

    def clean_directory(self, dirname):
        delete_list = []
        for f in os.listdir(dirname):
            add = False
            fullname = os.path.join(dirname, f)
            if os.path.isdir(fullname):
                if f == '.' or f == '..':
                    continue
                elif f.startswith(source_package_name):
                    add = True
            else:
                (fbase, fext) = os.path.splitext(f)
                last_dot = fbase.rfind('.')
                last_underscore = fbase.rfind('_')
                if last_dot != -1 and last_dot > last_underscore:
                    (fbase2, fext2) = os.path.splitext(fbase)
                    fext2_num = None
                    try:
                        fext2_num = int(fext2[1:])
                    except ValueError:
                        pass

                    if fext2_num is None:
                        fext = fext2 + fext
                        fbase = fbase2
                #print(fbase, fext)
                add = True if fext in ['.deb', '.dsc', '.pyc', '.changes', '.build', '.tar.gz', '.tar.xz'] else False
                if not add and fbase.endswith('_source'):
                    add = True

            if add:
                delete_list.append(os.path.join(dirname, f))
        ret = True
        for f in delete_list:
            try:
                if os.path.isdir(f):
                    shutil.rmtree(f)
                else:
                    os.remove(f)
            except OSError:
                ret = False
        #print(delete_list)
        return ret

    def debug(self, *args):
        if self.verbose:
            print(' '.join(args))

    def message(self, *args):
        if self.verbose:
            print(' '.join(args))

    def info(self, *args):
        print(' '.join(args))

    def warning(self, *args):
        print(' '.join(args))
            
    def error(self, *args):
        print(' '.join(args))

    def main(self):

        #=============================================================================================
        # process command line
        #=============================================================================================
        parser = argparse.ArgumentParser(description='generate the arsoft meta packages for Ubuntu/Kubuntu.')
        parser.add_argument('-v', '--verbose', dest='verbose', action='store_true', help='enable verbose output.')
        parser.add_argument('--version', dest='version', action='store_true', help='shows the version and exits.')
        parser.add_argument('-c', '--clean', dest='clean', action='store_true', help='clean the source directory')
        parser.add_argument('-b', '--build', dest='build', action='store_true', help='build the package after preparation')
        parser.add_argument('--binary', dest='build_binary', action='store_true', help='build the binary packages after preparation')
        parser.add_argument('-p', '--put', dest='put', action='store_true', help='upload the package to launchpad')
        parser.add_argument('-k', '--keep', dest='keep', action='store_true', help='keep the package dir after successful build')
        parser.add_argument('-d', '--distribution', dest='distribution', metavar='DISTRO', nargs='*', default=default_distributions, help='specify the distribution name')
        parser.add_argument('-g', '--groups', dest='groups', metavar='GRP', nargs='*', help='select the groups to be generated (default: all)')

        args = parser.parse_args()

        self.verbose = args.verbose
        self.build = args.build
        self.build_binary = args.build_binary
        self.put = args.put
        self.selected_groups = args.groups
        self.distributions = args.distribution
        self.clean = True if args.keep == False else False
        self.clean_source_dir = args.clean

        if self.put and not self.build and not self.clean_source_dir:
            self.build = True

        ret = 0
        if self.clean_source_dir:
            if not self.clean_directory(os.path.dirname(os.path.abspath(__file__))):
                ret = 1
        else:
            if len(self.distributions) == 0:
                #dist = self.get_distribution_codename()
                #if self.verbose:
                    #print "Distributions: " + str(dist)
                self.distributions = default_distributions
            else:
                for d in self.distributions:
                    if d not in all_distributions:
                        print("Unknown distribution " + d + ". Abort")
                        return 1

            for distribution in self.distributions:
                if self.verbose:
                    print("Prepare package for distribution " + str(distribution))
                (package_name, package_latest_full_version, package_latest_short_version) = self.get_latest_version_from_changelog(package_changelog, distribution)

                if self.verbose:
                    print("Package name: " + str(package_name))
                    print("Package version: " + str(package_latest_short_version) + " (" + package_latest_short_version + ")")

                (package_dir, package_debian_dir) = self.make_package_dir(None, package_name, package_latest_short_version, distribution)
                package_debian_control = os.path.join(package_debian_dir, 'control')
                package_debian_changelog = os.path.join(package_debian_dir, 'changelog')

                self.generate_debian_control(package_debian_control, package_latest_short_version, distribution)
                self.generate_debian_changelog(package_debian_changelog, distribution, package_changelog)
                self.generate_debian_postinst(package_debian_dir, distribution)

                if self.build:
                    if self.do_build(package_dir, binary=self.build_binary) and self.put:
                        self.do_put(package_dir, package_latest_full_version, distribution)
                else:
                    print("Done generating packages for " + str(distribution))
                if self.clean:
                    self.do_clean(package_dir, package_latest_full_version, distribution)
        return ret

if __name__ == '__main__':
    app = application()
    sys.exit(app.main())
